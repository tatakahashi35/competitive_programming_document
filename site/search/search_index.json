{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"graph/bfs/","text":"Note \u672a\u691c\u8a3c void dfs(long long vertex_id, Graph &graph){ queue<Vertex> q; q.push(graph.vertice[vertex_id]); while(!q.empty()){ Vertex vertex = q.front(); q.pop(); graph.vertice[vertex.id].visited = true; vector<Edge> next_edges = graph.next(start); for(Edge &edge : next_edges){ if(!graph.vertice[edge.to].visited){ graph.vertice[edge.to].visited = true; graph.vertice[edge.to].distance = vertex.distance + edge.weight; q.push(graph.vertice[edge.to]); } } } }","title":"bfs"},{"location":"graph/dfs/","text":"Note \u672a\u691c\u8a3c void dfs(long long vertex_id, Graph &graph){ Vertex start = graph.vertice[vertex_id]; start.visited = true; vector<Edge> next_edges = graph.next(start); for(Edge &edge : next_edges){ if(!graph.vertice[edge.to].visited){ dfs(edge.to, graph); } } }","title":"dfs"},{"location":"graph/dijkstra/","text":"Note \u672a\u691c\u8a3c void dijkstra(long long vertex_id, Graph &graph){ priority_queue<Vertex> pq; pq.push(graph.vertice[vertex_id]); while(!pq.empty()){ Vertex vertex = pq.front(); pq.pop(); vector<Edge> next_edges = graph.next(start); for(Edge &edge : next_edges){ if(graph.vertice[edge.to].distance < vertex.distance + edge.weight){ graph.vertice[edge.to].distance = vertex.distance + edge.weight; pq.push(graph.vertice[edge.to]); } } } }","title":"dijkstra"},{"location":"graph/graph/","text":"Note \u672a\u691c\u8a3c class Vertex{ public: long long id; long long weight; // \u70b9\u91cd\u307f long long distance; // \u3053\u3053\u307e\u3067\u306e\u8ddd\u96e2 bool visited; Vertex(long long i, long long w){ id = i; weight = w; distance = 0LL; visited = false; } Vertex(long long i){ Vertex(i, 0LL); } bool operator<(const Vertex &v) const{ // distance \u3067\u6bd4\u8f03 if(distance < v.distance){ return true; }else if(distance > v.distance){ return false; }else{ if(id < v.id){ return true; }else if(id > v.id){ return false; }else{ return false; } } } bool operator==(const Vertex &v) const{ if(id == v.id){ return true; } return false; } inline bool operator!=(const Vertex& v) const{ return !(*this == v); } }; class Edge{ static long long id_count; public: long long id; long long from, to; long long weight; // \u679d\u91cd\u307f Edge(long long f, long long t, long long w){ id = id_count++; from = f; to = t; weight = w; } Edge(long long f, long long t){ Edge(f, t, 1LL); } bool operator<(const Edge &e) const{ if(weight < e.weight){ return true; }else if(weight > e.weight){ return false; }else{ if(from < e.from){ return true; }else if(from > e.from){ return false; }else{ if(to < e.to){ return true; }else if(to > e.to){ return false; }else{ return false; } } } } bool operator==(const Edge &e) const{ if(id == e.id){ return true; } return false; } inline bool operator!=(const Edge& e) const{ return !(*this == e); } }; long long Edge::id_count = 0; class Graph{ public: long long number_of_vertice; long long number_of_edges; vector<Vertex> vertice; vector<vector<Edge>> edges; // \u96a3\u63a5\u30ea\u30b9\u30c8 Graph(long long N, long long M){ number_of_vertice = N; number_of_edges = M; vertice.resize(N); edges.resize(N); } vector<Edge> next(Vertex vertex){ // \u96a3\u63a5\u679d\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 return edges[vertex.id]; } };","title":"graph"},{"location":"graph/segment_tree/","text":"Note \u672a\u691c\u8a3c class SegmentTree{ public: long long n; // \u5bfe\u8c61\u3068\u306a\u308b\u914d\u5217\u306e\u8981\u7d20\u6570 long long n_0_filled; // \u5bfe\u8c61\u3068\u306a\u308b\u914d\u5217\u306e\u8981\u7d20\u6570 (0\u57cb\u3081\u5206\u5f8c) long long node; // segment tree \u306e\u8981\u7d20\u6570 vector<long long> tree; SegmentTree(long long N){ n = N; long long d = (long long)(ceill(log2(n))); n_0_filled = pow(2, d); node = 2 * n_0_filled - 1; tree = vector<long long>(node, 0); } void init(std::vector<long long> &A){ for(int i = 0; i < n; ++i){ update(i, A[i]); } } // \u8981\u4fee\u6b63 long long update_calculation(long long a, long long b){ // \u8981\u7d20\u306b\u5bfe\u3059\u308b\u8a08\u7b97 return min(a, b); } void update(long long index, long long value){ index = node - n_0_filled + index; tree[index] = update_calculation(tree[index], value); while(index > 0){ index = (index - 1) / 2; tree[index] = query_calculation(index * 2 + 1, index * 2 + 2); } } // \u8981\u4fee\u6b63 long long query_calculation(long long a, long long b){ // \u7bc4\u56f2\u306b\u5bfe\u3059\u308b\u8a08\u7b97 return min(a, b); } long long query(long long a, long long b){ // l \u4ee5\u4e0a r \u672a\u6e80\u306e\u533a\u9593\u306b\u5bfe\u3057\u3066 query_calculation() \u306e\u7d50\u679c\u3092\u6c42\u3081\u308b return query_sub(a, b, 0, 0, n_0_filled); } long long query_sub(long long a, long long b, long long k, long long l, long long r){ if(r <= a || b <= l){ // \u533a\u9593\u5916\u3092\u542b\u3093\u3067\u3044\u308b return 0; }else if(a <= l && r <= b){ return tree[k]; }else{ long long left_value = query_sub(a, b, 2 * k + 1, l, (l + r) / 2); long long right_value = query_sub(a, b, 2 * k + 2, (l + r) / 2, r); return query_calculation(left_value, right_value); } } };","title":"segment tree"},{"location":"graph/union_find/","text":"Note \u672a\u691c\u8a3c class UnionFind{ public: long long N; long long groups; vector<long long> parent; UnionFind(long long n){ N = n; groups = N; parent.resize(N); iota(parent.begin(), parent.end(), 0); } long long get_parent(long long i){ if(parent[i] < 0){ return i; } return parent[i] = get_parent(parent[i]); } long long get_size(long long i){ return -p[parent(i)]; } void union_groups(long long a, long long b){ a = parent(a); b = parent(b); if(a != b){ if(p[a] > p[b]){ swap(a, b); } p[a] += p[b]; p[b] = a; groups--; } } union_find = UnionFind(N);","title":"union find"},{"location":"math/combination/","text":"Note \u672a\u691c\u8a3c template< long long mod > class Combination { public: // nC0 ~ nCn long long n; vector<ModInt<mod>> factorial; vector<ModInt<mod>> inverse_factorial; Combination(long long nn){ n = nn; factorial.resize(n+1); inverse_factorial.resize(n+1); } void calc_factorial(){ factorial[0] = ModInt<mod>(1); inverse_factorial[0] = ModInt<mod>(1); for(int i=1; i<n+1; ++i){ factorial[i] = factorial[i-1] * ModInt<mod>(i); inverse_factorial[i] = inverse_factorial[i-1] / ModInt<mod>(i); } } ModInt<mod> calc_combination(long long n, long long k){ if(n < 0 || k < 0 || n < k){ return ModInt<mod>(0); } return factorial[n] * (inverse_factorial[k] * inverse_factorial[n-k]); } };","title":"combination"},{"location":"math/gcd/","text":"gcd, lcm Note \u672a\u691c\u8a3c tuple<long long, long long, long long> gcd(long long x, long long y) { // C = GCD(X, Y) // C = A * X + B * Y // return (C, A, B) long long a = x, b = y; long long r, q; long long u_2 = 1, u_1 = 0, v_2 = 0, v_1 = 1, u, v; r = a % b; q = a / b; u = u_2 - q * u_1; v = v_2 - q * v_1; while(r != 0){ a = b; b = r; r = a % b; q = a / b; u_2 = u_1; u_1 = u; v_2 = v_1; v_1 = v; u = u_2 - q * u_1; v = v_2 - q * v_1; } return forward_as_tuple(b, u_1, v_1); } Note \u672a\u691c\u8a3c long long lcm(long long x, long long y){ long long a, b, c; tie(c, a, b) = gcd(x, y); return x / c * y; }","title":"gcd"},{"location":"math/gcd/#gcd-lcm","text":"Note \u672a\u691c\u8a3c tuple<long long, long long, long long> gcd(long long x, long long y) { // C = GCD(X, Y) // C = A * X + B * Y // return (C, A, B) long long a = x, b = y; long long r, q; long long u_2 = 1, u_1 = 0, v_2 = 0, v_1 = 1, u, v; r = a % b; q = a / b; u = u_2 - q * u_1; v = v_2 - q * v_1; while(r != 0){ a = b; b = r; r = a % b; q = a / b; u_2 = u_1; u_1 = u; v_2 = v_1; v_1 = v; u = u_2 - q * u_1; v = v_2 - q * v_1; } return forward_as_tuple(b, u_1, v_1); } Note \u672a\u691c\u8a3c long long lcm(long long x, long long y){ long long a, b, c; tie(c, a, b) = gcd(x, y); return x / c * y; }","title":"gcd, lcm"},{"location":"math/math/","text":"math floor int(floor(1.5)) ceil int(ceil(1.5)) sqrt sqrt(2.5) log log(2.5) log2(2.5) log10(2.5) \u70b9\u3068\u76f4\u7dda\u306e\u8ddd\u96e2 ax + by + c = 0 \u3068 (x0, y0) \u306e\u8ddd\u96e2 double dist = abs(a * x0 + b * y0 + c) / sqrt(a * a + b * b);","title":"math"},{"location":"math/math/#math","text":"","title":"math"},{"location":"math/math/#floor","text":"int(floor(1.5))","title":"floor"},{"location":"math/math/#ceil","text":"int(ceil(1.5))","title":"ceil"},{"location":"math/math/#sqrt","text":"sqrt(2.5)","title":"sqrt"},{"location":"math/math/#log","text":"log(2.5) log2(2.5) log10(2.5)","title":"log"},{"location":"math/math/#_1","text":"ax + by + c = 0 \u3068 (x0, y0) \u306e\u8ddd\u96e2 double dist = abs(a * x0 + b * y0 + c) / sqrt(a * a + b * b);","title":"\u70b9\u3068\u76f4\u7dda\u306e\u8ddd\u96e2"},{"location":"math/modint/","text":"Note \u672a\u691c\u8a3c template< long long mod > class ModInt { public: long long x; ModInt(long long xx){ if(xx < 0){ x = (xx + mod) % mod; }else{ x = xx; } } ModInt(){ ModInt(0); } ModInt &operator+=(const ModInt &p) { if((x += p.x) >= mod) x -= mod; return *this; } ModInt &operator-=(const ModInt &p) { if((x += mod - p.x) >= mod) x -= mod; return *this; } ModInt &operator*=(const ModInt &p) { x = x * p.x % mod; return *this; } ModInt &operator/=(const ModInt &p) { *this *= p.inverse(); return *this; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; } bool operator==(const ModInt &p) const { return x == p.x; } inline bool operator!=(const ModInt& p) const{ return !(*this == p); } friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; } friend istream &operator>>(istream &is, ModInt &p) { long long t; is >> t; p = ModInt(t); return (is); } ModInt inverse() const { long long a = x, b = mod, u = 1, v = 0, t; while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(long long n) const { bool negative = false; if(n < 0){ negative = true; n = abs(n); } ModInt ret(1), mul(x); while(n > 0) { if(n & 1) ret *= mul; mul *= mul; n >>= 1; } if(negative == true){ return ret.inverse(); } return ret; } };","title":"modint"},{"location":"math/pow/","text":"Note \u672a\u691c\u8a3c long long pow(long long a, long long n, long long m){ if(n == 0){ return 1LL; }else if(n == 1){ return a % m; }else if(n % 2 == 0){ long long b = pow(a, n / 2, m); return b * b % m; }else{ return a * pow(a, n - 1, m) % m; } }","title":"pow"},{"location":"math/prime/","text":"prime Note \u672a\u691c\u8a3c vector<long long> calc_primes(long long n){ // n \u672a\u6e80\u306e\u7d20\u6570\u3092\u8fd4\u3059 vector<long long> primes; if(n < 2){ return primes; } // init vector<bool> prime_pool(n, true); prime_pool[0] = false; prime_pool[1] = false; long long upper = (long long)ceill(sqrtl(n))) + 1LL; long long k = 2; while(k < upper){ while(k < upper){ if(prime_pool[k]){ // k: prime number primes.push_back(k); break; } k++; } long long next_prime = k; for(long long i = next_prime * next_prime; i < upper; i += next_prime){ prime_pool[i] = true; } k++; } for(int i = primes[primes.size() - 1]; i < n; ++i){ if(prime_pool[i]){ primes.push_back(i); } } return primes; Note \u672a\u691c\u8a3c map<long long> prime_factor(long long n){ // \u7d20\u56e0\u6570\u5206\u89e3 vector<long long> primes = calc_primes(n + 1); // N + 1 \u672a\u6e80\u306e\u7d20\u6570 long long number_of_primes = primes.size(); map<long, long> prime_factors; long long sqrt_n = (long long)ceill(sqrtl(n))) + 1LL; for(long long i = 0; i < number_of_primes; ++i){ if(n == 1){ break; } if(n % primes[i] == 0){ n /= primes[i]; prime_factors[primes[i]] = 1; while(n % primes[i] == 0){ n /= primes[i]; prime_factors[primes[i]]++; } } } return prime_factors; }","title":"prime"},{"location":"math/prime/#prime","text":"Note \u672a\u691c\u8a3c vector<long long> calc_primes(long long n){ // n \u672a\u6e80\u306e\u7d20\u6570\u3092\u8fd4\u3059 vector<long long> primes; if(n < 2){ return primes; } // init vector<bool> prime_pool(n, true); prime_pool[0] = false; prime_pool[1] = false; long long upper = (long long)ceill(sqrtl(n))) + 1LL; long long k = 2; while(k < upper){ while(k < upper){ if(prime_pool[k]){ // k: prime number primes.push_back(k); break; } k++; } long long next_prime = k; for(long long i = next_prime * next_prime; i < upper; i += next_prime){ prime_pool[i] = true; } k++; } for(int i = primes[primes.size() - 1]; i < n; ++i){ if(prime_pool[i]){ primes.push_back(i); } } return primes; Note \u672a\u691c\u8a3c map<long long> prime_factor(long long n){ // \u7d20\u56e0\u6570\u5206\u89e3 vector<long long> primes = calc_primes(n + 1); // N + 1 \u672a\u6e80\u306e\u7d20\u6570 long long number_of_primes = primes.size(); map<long, long> prime_factors; long long sqrt_n = (long long)ceill(sqrtl(n))) + 1LL; for(long long i = 0; i < number_of_primes; ++i){ if(n == 1){ break; } if(n % primes[i] == 0){ n /= primes[i]; prime_factors[primes[i]] = 1; while(n % primes[i] == 0){ n /= primes[i]; prime_factors[primes[i]]++; } } } return prime_factors; }","title":"prime"},{"location":"syntax/map/","text":"map initialize map<int, int> dic; map<int, int> dic{ {1: 2}, {3: 4}, {5: 6}, }; for \u53c2\u7167 for (auto const& [key, value] : dic){ cout<<key<<\" \"<<value<<endl; }","title":"map"},{"location":"syntax/map/#map","text":"","title":"map"},{"location":"syntax/map/#initialize","text":"map<int, int> dic; map<int, int> dic{ {1: 2}, {3: 4}, {5: 6}, };","title":"initialize"},{"location":"syntax/map/#for","text":"\u53c2\u7167 for (auto const& [key, value] : dic){ cout<<key<<\" \"<<value<<endl; }","title":"for"},{"location":"syntax/pair/","text":"pair initialize pair<int, string> p; p = make_pair(123, \"hoge\"); cout<<p.first<<endl; // 123 cout<<p.second<<endl; // hoge","title":"pair"},{"location":"syntax/pair/#pair","text":"","title":"pair"},{"location":"syntax/pair/#initialize","text":"pair<int, string> p; p = make_pair(123, \"hoge\"); cout<<p.first<<endl; // 123 cout<<p.second<<endl; // hoge","title":"initialize"},{"location":"syntax/set/","text":"set initialize set<int> s; insert s.insert(1);","title":"set"},{"location":"syntax/set/#set","text":"","title":"set"},{"location":"syntax/set/#initialize","text":"set<int> s;","title":"initialize"},{"location":"syntax/set/#insert","text":"s.insert(1);","title":"insert"},{"location":"syntax/string/","text":"string substr s = \"hogehoge\"; s.substr(1, 3); // \"oge\" int \u2192 string \u5909\u63db ll num = 123; to_string(num); Note \u672a\u691c\u8a3c auto a = std::string() + 'a'; // \"a\" auto b = \"\"s + 'b'; // \"b\" (C++14) \u691c\u7d22 string word = \"word\"; if (str.find(word) == string::npos){ // \u307f\u3064\u304b\u3089\u306a\u304b\u3063\u305f }else{ // \u307f\u3064\u304b\u3063\u305f }","title":"string"},{"location":"syntax/string/#string","text":"","title":"string"},{"location":"syntax/string/#substr","text":"s = \"hogehoge\"; s.substr(1, 3); // \"oge\"","title":"substr"},{"location":"syntax/string/#int-string","text":"ll num = 123; to_string(num); Note \u672a\u691c\u8a3c auto a = std::string() + 'a'; // \"a\" auto b = \"\"s + 'b'; // \"b\" (C++14)","title":"int \u2192 string \u5909\u63db"},{"location":"syntax/string/#_1","text":"string word = \"word\"; if (str.find(word) == string::npos){ // \u307f\u3064\u304b\u3089\u306a\u304b\u3063\u305f }else{ // \u307f\u3064\u304b\u3063\u305f }","title":"\u691c\u7d22"},{"location":"syntax/vector/","text":"vector initialize // N\u884cM\u5217\u306e\u4e8c\u6b21\u5143vector\u306e\u5ba3\u8a00 vector<vector<long>> edges(N, vector<long>(M, 0)); // 3\u6b21\u5143 vector<vector<vector<long>>> data(N, vector<vector<long>>(M, vector<long>(K))); // \u521d\u671f\u5316 vector<vector<long>> edges(N, vector<long>(M, 0)); // \u540c\u3058\u5024\u3067\u57cb\u3081\u308b fill(vec.begin(),vec.end(), 3); // \u9023\u756a iota(vec.begin(), vec.end(), 0); for \u53c2\u7167 for(auto v : vec){ cout<<v<<\" \"; } cout<<endl; \u4ee3\u5165 for(auto &v : vec){ v = v * 2; } max, min auto max_itr = max_element(vec.begin(), vec.end()); auto min_itr = min_element(vec.begin(), vec.end()); sort sort(vec.begin(), vec.end()); accumulate sum accumulate(vec.begin(), vec.end(), 0); \u6587\u5b57\u5217\u9023\u7d50 accumulate(vec.begin(), vec.end(), string()); \u4efb\u610f\u306e\u4e8c\u9805\u6f14\u7b97 (\u521d\u671f\u5024\u3092 1 \u306b\u8a2d\u5b9a) accumulate(vec.begin(), vec.end(), 1, [](int acc, int i) { return acc * i; // \u03a0 (\u5168\u8981\u7d20\u306e\u7a4d) }); binary search // \u7b2c3\u5f15\u6570\u4ee5\u4e0a\u306b\u306a\u308b\u6700\u521d\u306e\u8981\u7d20\u3092\u6307\u3059\u30a4\u30c6\u30ec\u30fc\u30bf\u3092\u8fd4\u3059 lower_bound(vec.begin(), vec.end(), 123); // \u7b2c3\u5f15\u6570\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u6700\u521d\u306e\u8981\u7d20\u3092\u6307\u3059\u30a4\u30c6\u30ec\u30fc\u30bf\u3092\u8fd4\u3059 upper_bound(vec.begin(), vec.end(), 123); // \u7b2c3\u5f15\u6570\u304c\u5b58\u5728\u3059\u308b\u304b\u3092\u8868\u3059bool\u3092\u8fd4\u3059 binary_search(vec.begin(), vec.end(), 123); index \u3092\u8fd4\u3059 auto itr = find(vec.begin(), vec.end(), 123); int index = distance(vec.begin(), itr);","title":"vector"},{"location":"syntax/vector/#vector","text":"","title":"vector"},{"location":"syntax/vector/#initialize","text":"// N\u884cM\u5217\u306e\u4e8c\u6b21\u5143vector\u306e\u5ba3\u8a00 vector<vector<long>> edges(N, vector<long>(M, 0)); // 3\u6b21\u5143 vector<vector<vector<long>>> data(N, vector<vector<long>>(M, vector<long>(K))); // \u521d\u671f\u5316 vector<vector<long>> edges(N, vector<long>(M, 0)); // \u540c\u3058\u5024\u3067\u57cb\u3081\u308b fill(vec.begin(),vec.end(), 3); // \u9023\u756a iota(vec.begin(), vec.end(), 0);","title":"initialize"},{"location":"syntax/vector/#for","text":"\u53c2\u7167 for(auto v : vec){ cout<<v<<\" \"; } cout<<endl; \u4ee3\u5165 for(auto &v : vec){ v = v * 2; }","title":"for"},{"location":"syntax/vector/#max-min","text":"auto max_itr = max_element(vec.begin(), vec.end()); auto min_itr = min_element(vec.begin(), vec.end());","title":"max, min"},{"location":"syntax/vector/#sort","text":"sort(vec.begin(), vec.end());","title":"sort"},{"location":"syntax/vector/#accumulate","text":"sum accumulate(vec.begin(), vec.end(), 0); \u6587\u5b57\u5217\u9023\u7d50 accumulate(vec.begin(), vec.end(), string()); \u4efb\u610f\u306e\u4e8c\u9805\u6f14\u7b97 (\u521d\u671f\u5024\u3092 1 \u306b\u8a2d\u5b9a) accumulate(vec.begin(), vec.end(), 1, [](int acc, int i) { return acc * i; // \u03a0 (\u5168\u8981\u7d20\u306e\u7a4d) });","title":"accumulate"},{"location":"syntax/vector/#binary-search","text":"// \u7b2c3\u5f15\u6570\u4ee5\u4e0a\u306b\u306a\u308b\u6700\u521d\u306e\u8981\u7d20\u3092\u6307\u3059\u30a4\u30c6\u30ec\u30fc\u30bf\u3092\u8fd4\u3059 lower_bound(vec.begin(), vec.end(), 123); // \u7b2c3\u5f15\u6570\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u6700\u521d\u306e\u8981\u7d20\u3092\u6307\u3059\u30a4\u30c6\u30ec\u30fc\u30bf\u3092\u8fd4\u3059 upper_bound(vec.begin(), vec.end(), 123); // \u7b2c3\u5f15\u6570\u304c\u5b58\u5728\u3059\u308b\u304b\u3092\u8868\u3059bool\u3092\u8fd4\u3059 binary_search(vec.begin(), vec.end(), 123);","title":"binary search"},{"location":"syntax/vector/#index","text":"auto itr = find(vec.begin(), vec.end(), 123); int index = distance(vec.begin(), itr);","title":"index \u3092\u8fd4\u3059"},{"location":"util/util/","text":"util Note \u672a\u691c\u8a3c template<class T> T my_min(T head, T next){ return min(head, next); } template <class T, class... T> T my_min(T head, T... body){ return min(head, my_min(body...)); } Note \u672a\u691c\u8a3c template<class T> T my_max(T head, T next){ return max(head, next); } template <class T, class... T> T my_max(T head, T... body){ return max(head, my_max(body...)); } Note \u672a\u691c\u8a3c bool comp(int i, int j) { return vec[i] < vec[j] } vector<long long> vec(N); // sort target vector<long long> index(N); iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), comp); \u51fa\u529b printf(\"%lld\\n\", answer);","title":"util"},{"location":"util/util/#util","text":"Note \u672a\u691c\u8a3c template<class T> T my_min(T head, T next){ return min(head, next); } template <class T, class... T> T my_min(T head, T... body){ return min(head, my_min(body...)); } Note \u672a\u691c\u8a3c template<class T> T my_max(T head, T next){ return max(head, next); } template <class T, class... T> T my_max(T head, T... body){ return max(head, my_max(body...)); } Note \u672a\u691c\u8a3c bool comp(int i, int j) { return vec[i] < vec[j] } vector<long long> vec(N); // sort target vector<long long> index(N); iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), comp);","title":"util"},{"location":"util/util/#_1","text":"printf(\"%lld\\n\", answer);","title":"\u51fa\u529b"}]}